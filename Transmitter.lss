
Transmitter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003c4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000005  00800100  00800100  00000438  2**0
                  ALLOC
  2 .debug_aranges 00000020  00000000  00000000  00000438  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000c5  00000000  00000000  00000458  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000008aa  00000000  00000000  0000051d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000224  00000000  00000000  00000dc7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   0000062a  00000000  00000000  00000feb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000000c0  00000000  00000000  00001618  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000196  00000000  00000000  000016d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000023e  00000000  00000000  0000186e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000000a8  00000000  00000000  00001aac  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 a2 01 	jmp	0x344	; 0x344 <__vector_1>
   8:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  10:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  14:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  18:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  1c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  20:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  24:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  28:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  2c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  30:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  34:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  38:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  3c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  40:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  44:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  48:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  4c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  50:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  54:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  58:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  5c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  60:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  64:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	a5 30       	cpi	r26, 0x05	; 5
  80:	b1 07       	cpc	r27, r17
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
  84:	0e 94 53 01 	call	0x2a6	; 0x2a6 <main>
  88:	0c 94 e0 01 	jmp	0x3c0	; 0x3c0 <_exit>

0000008c <__bad_interrupt>:
  8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000090 <SPI_MasterInit>:
}

void SPI_MasterInit(void)
{
	/*Set CE, MOSI, SCK, and SS/CSN as output */
	DDRB |= (1 << 1)|(1 << 2)|(1 << 3)|(1 << 5);
  90:	84 b1       	in	r24, 0x04	; 4
  92:	8e 62       	ori	r24, 0x2E	; 46
  94:	84 b9       	out	0x04, r24	; 4
	DDRB &= ~(1 << 4);//set MISO as input
  96:	24 98       	cbi	0x04, 4	; 4
	/*Set as Master, set clock rate fck/128, SpiEnable */
	SPCR |= (1 << MSTR);
  98:	8c b5       	in	r24, 0x2c	; 44
  9a:	80 61       	ori	r24, 0x10	; 16
  9c:	8c bd       	out	0x2c, r24	; 44
	SPCR |= (1 << SPR0)|(1 << SPR1);
  9e:	8c b5       	in	r24, 0x2c	; 44
  a0:	83 60       	ori	r24, 0x03	; 3
  a2:	8c bd       	out	0x2c, r24	; 44
	SPCR |= (1 << SPE);
  a4:	8c b5       	in	r24, 0x2c	; 44
  a6:	80 64       	ori	r24, 0x40	; 64
  a8:	8c bd       	out	0x2c, r24	; 44
	
	PORTB |= (1 << 2);//CSN high to begin with, no communication with NRF yet
  aa:	2a 9a       	sbi	0x05, 2	; 5
	PORTB &= ~(1 << 1);//CE low to begin with since nothing being sent/received
  ac:	29 98       	cbi	0x05, 1	; 5
}
  ae:	08 95       	ret

000000b0 <WriteByteSPI>:

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
  b0:	8e bd       	out	0x2e, r24	; 46
	/*Wait for transmission*/
	while(!(SPSR & (1 << SPIF)))
  b2:	0d b4       	in	r0, 0x2d	; 45
  b4:	07 fe       	sbrs	r0, 7
  b6:	fd cf       	rjmp	.-6      	; 0xb2 <WriteByteSPI+0x2>
		;
	return SPDR;//return what's recieved to the nRF
  b8:	8e b5       	in	r24, 0x2e	; 46
}
  ba:	08 95       	ret

000000bc <INT0_interrupt_init>:

void INT0_interrupt_init(void)	
{
	DDRD &= ~(1 << DDD2);	//Set pin 4 as input (INT0 pin)
  bc:	52 98       	cbi	0x0a, 2	; 10
	
	EICRA |=  (1 << ISC01);// INT0 falling edge	PD2
  be:	e9 e6       	ldi	r30, 0x69	; 105
  c0:	f0 e0       	ldi	r31, 0x00	; 0
  c2:	80 81       	ld	r24, Z
  c4:	82 60       	ori	r24, 0x02	; 2
  c6:	80 83       	st	Z, r24
	EICRA  &=  ~(1 << ISC00);// INT0 falling edge	PD2
  c8:	80 81       	ld	r24, Z
  ca:	8e 7f       	andi	r24, 0xFE	; 254
  cc:	80 83       	st	Z, r24
 
	EIMSK |=  (1 << INT0);	//enable int0
  ce:	e8 9a       	sbi	0x1d, 0	; 29
  	//sei();
} 
  d0:	08 95       	ret

000000d2 <WriteToNrf>:

/*****************nrf-setup**************************///Sets the nrf first by sending the register, then the value of the register.
uint8_t *WriteToNrf(uint8_t ReadWrite, uint8_t reg, uint8_t *val, uint8_t antVal)	//takes in "ReadWrite" (W or R), "reg" (ett register), "*val" (an array) & "antVal" (number of values in val)
{
  d2:	1f 93       	push	r17
  d4:	78 2f       	mov	r23, r24
	cli();	//disable global interrupts
  d6:	f8 94       	cli
	
	if (ReadWrite == W)	//W = write to nrf (R= reads it, R_REGISTER (0x00)
  d8:	81 30       	cpi	r24, 0x01	; 1
  da:	09 f4       	brne	.+2      	; 0xde <WriteToNrf+0xc>
	{
		reg = W_REGISTER + reg;	//ex: reg = EN_AA: 0b0010 0000 + 0b0000 0001 = 0b0010 0001  
  dc:	60 5e       	subi	r22, 0xE0	; 224
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
  de:	85 e3       	ldi	r24, 0x35	; 53
  e0:	98 2f       	mov	r25, r24
  e2:	9a 95       	dec	r25
  e4:	f1 f7       	brne	.-4      	; 0xe2 <WriteToNrf+0x10>
	
	//Static uint8_t returns an array (note the "*")
	static uint8_t ret[dataLen];	//assume that the longest you want it to read when it calls the "R" is n(some amount) - far, and that it uses only 1 byte times n. You want to read out 5 bytes RF_Address so the write 5 is here!!	
	
	_delay_us(10);		//the proper delay for the NRF! (microseconds)
	PORTB &= ~(1 << 2);;	//CSN low = nrf chip starts listening
  e6:	2a 98       	cbi	0x05, 2	; 5
  e8:	8a 95       	dec	r24
  ea:	f1 f7       	brne	.-4      	; 0xe8 <WriteToNrf+0x16>

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
  ec:	6e bd       	out	0x2e, r22	; 46
	/*Wait for transmission*/
	while(!(SPSR & (1 << SPIF)))
  ee:	0d b4       	in	r0, 0x2d	; 45
  f0:	07 fe       	sbrs	r0, 7
  f2:	fd cf       	rjmp	.-6      	; 0xee <WriteToNrf+0x1c>
		;
	return SPDR;//return what's recieved to the nRF
  f4:	8e b5       	in	r24, 0x2e	; 46
  f6:	85 e3       	ldi	r24, 0x35	; 53
  f8:	8a 95       	dec	r24
  fa:	f1 f7       	brne	.-4      	; 0xf8 <WriteToNrf+0x26>
  fc:	a0 e0       	ldi	r26, 0x00	; 0
  fe:	b0 e0       	ldi	r27, 0x00	; 0
	_delay_us(10);		
	WriteByteSPI(reg);	//set the nRF to write or read mode of "reg"
	_delay_us(10); 		
	
	int i;
	for(i=0; i<antVal; i++)
 100:	30 e0       	ldi	r19, 0x00	; 0
 102:	95 e3       	ldi	r25, 0x35	; 53

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
 104:	1f ef       	ldi	r17, 0xFF	; 255
 106:	1b c0       	rjmp	.+54     	; 0x13e <WriteToNrf+0x6c>
	_delay_us(10); 		
	
	int i;
	for(i=0; i<antVal; i++)
	{
		if (ReadWrite == R && reg != W_TX_PAYLOAD)//want to read a registry?
 108:	77 23       	and	r23, r23
 10a:	61 f4       	brne	.+24     	; 0x124 <WriteToNrf+0x52>
 10c:	60 3a       	cpi	r22, 0xA0	; 160
 10e:	51 f0       	breq	.+20     	; 0x124 <WriteToNrf+0x52>

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
 110:	1e bd       	out	0x2e, r17	; 46
	/*Wait for transmission*/
	while(!(SPSR & (1 << SPIF)))
 112:	0d b4       	in	r0, 0x2d	; 45
 114:	07 fe       	sbrs	r0, 7
 116:	fd cf       	rjmp	.-6      	; 0x112 <WriteToNrf+0x40>
		;
	return SPDR;//return what's recieved to the nRF
 118:	8e b5       	in	r24, 0x2e	; 46
	int i;
	for(i=0; i<antVal; i++)
	{
		if (ReadWrite == R && reg != W_TX_PAYLOAD)//want to read a registry?
		{
			ret[i]=WriteByteSPI(NOP);//send dummy bytes to read out the data
 11a:	fd 01       	movw	r30, r26
 11c:	e0 50       	subi	r30, 0x00	; 0
 11e:	ff 4f       	sbci	r31, 0xFF	; 255
 120:	80 83       	st	Z, r24
 122:	09 c0       	rjmp	.+18     	; 0x136 <WriteToNrf+0x64>
			_delay_us(10);			
		}
		else 
		{
			WriteByteSPI(val[i]);//send commands to the nRF one at a time
 124:	fa 01       	movw	r30, r20
 126:	ea 0f       	add	r30, r26
 128:	fb 1f       	adc	r31, r27
 12a:	80 81       	ld	r24, Z

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
 12c:	8e bd       	out	0x2e, r24	; 46
	/*Wait for transmission*/
	while(!(SPSR & (1 << SPIF)))
 12e:	0d b4       	in	r0, 0x2d	; 45
 130:	07 fe       	sbrs	r0, 7
 132:	fd cf       	rjmp	.-6      	; 0x12e <WriteToNrf+0x5c>
		;
	return SPDR;//return what's recieved to the nRF
 134:	8e b5       	in	r24, 0x2e	; 46
 136:	89 2f       	mov	r24, r25
 138:	8a 95       	dec	r24
 13a:	f1 f7       	brne	.-4      	; 0x138 <WriteToNrf+0x66>
	_delay_us(10);		
	WriteByteSPI(reg);	//set the nRF to write or read mode of "reg"
	_delay_us(10); 		
	
	int i;
	for(i=0; i<antVal; i++)
 13c:	11 96       	adiw	r26, 0x01	; 1
 13e:	a2 17       	cp	r26, r18
 140:	b3 07       	cpc	r27, r19
 142:	14 f3       	brlt	.-60     	; 0x108 <WriteToNrf+0x36>
		{
			WriteByteSPI(val[i]);//send commands to the nRF one at a time
			_delay_us(10);
		}		
	}
	PORTB |= (1 << 2);	//CSN back to high - nrf chip stops listening
 144:	2a 9a       	sbi	0x05, 2	; 5
	
	sei(); //enable global interrupts
 146:	78 94       	sei
	
	return ret;	//returns an array
}
 148:	80 e0       	ldi	r24, 0x00	; 0
 14a:	91 e0       	ldi	r25, 0x01	; 1
 14c:	1f 91       	pop	r17
 14e:	08 95       	ret

00000150 <nrf24L01_init>:

/****************************************************************************************************************/

void nrf24L01_init(void)
{
 150:	ef 92       	push	r14
 152:	ff 92       	push	r15
 154:	1f 93       	push	r17
 156:	df 93       	push	r29
 158:	cf 93       	push	r28
 15a:	00 d0       	rcall	.+0      	; 0x15c <nrf24L01_init+0xc>
 15c:	00 d0       	rcall	.+0      	; 0x15e <nrf24L01_init+0xe>
 15e:	0f 92       	push	r0
 160:	cd b7       	in	r28, 0x3d	; 61
 162:	de b7       	in	r29, 0x3e	; 62
 164:	88 ee       	ldi	r24, 0xE8	; 232
 166:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 168:	20 e9       	ldi	r18, 0x90	; 144
 16a:	31 e0       	ldi	r19, 0x01	; 1
 16c:	f9 01       	movw	r30, r18
 16e:	31 97       	sbiw	r30, 0x01	; 1
 170:	f1 f7       	brne	.-4      	; 0x16e <nrf24L01_init+0x1e>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 172:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 174:	d9 f7       	brne	.-10     	; 0x16c <nrf24L01_init+0x1c>
	uint8_t val[5];	//an array of integers that sends values to WriteToNrf function
 
	//EN_AA - (auto-acknowledgments) - The transmitter will response of the receiver to-package arrived
	//(Need only be enablad the transmitter!)
	//Requires the transmitter also has sat SAME RF_Adress on its receiver channel below example: RX_ADDR_P0 = TX_ADDR
	val[0]=0x01;//gives first integern in the array "choice" one value: 0x01 = EN_AA on pipe P0.
 176:	11 e0       	ldi	r17, 0x01	; 1
 178:	19 83       	std	Y+1, r17	; 0x01
	WriteToNrf(W, EN_AA, val, 1);//W ='ll write / modify anything in the NRF, EN_AA = which register shall be amended, val = an array of 1 to 32 values ??to be written to the register, 1 = number of values be read out of "choice" array.
 17a:	81 e0       	ldi	r24, 0x01	; 1
 17c:	61 e0       	ldi	r22, 0x01	; 1
 17e:	7e 01       	movw	r14, r28
 180:	08 94       	sec
 182:	e1 1c       	adc	r14, r1
 184:	f1 1c       	adc	r15, r1
 186:	a7 01       	movw	r20, r14
 188:	21 e0       	ldi	r18, 0x01	; 1
 18a:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
	
	//SETUP_RETR (the setup for "EN_AA")
	val[0]=0x2F;//0b0010 00011 "2" sets it up to 750uS delay between every retry 
 18e:	8f e2       	ldi	r24, 0x2F	; 47
 190:	89 83       	std	Y+1, r24	; 0x01
	//(at least 500us at 250kbps and if payload >5bytes in 1Mbps, and if payload >15byte in 2Mbps)
    // "F" is number of retries (1-15, now 15)
	WriteToNrf(W, SETUP_RETR, val, 1);
 192:	81 e0       	ldi	r24, 0x01	; 1
 194:	64 e0       	ldi	r22, 0x04	; 4
 196:	a7 01       	movw	r20, r14
 198:	21 e0       	ldi	r18, 0x01	; 1
 19a:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
	
	//Selects which / what data pipes (0-5) that should be running.
	val[0]=0x01;
 19e:	19 83       	std	Y+1, r17	; 0x01
	WriteToNrf(W, EN_RXADDR, val, 1); //enable data pipe 0
 1a0:	81 e0       	ldi	r24, 0x01	; 1
 1a2:	62 e0       	ldi	r22, 0x02	; 2
 1a4:	a7 01       	movw	r20, r14
 1a6:	21 e0       	ldi	r18, 0x01	; 1
 1a8:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
 
    //RF_Adress width setup (how many bytes should RF_Adressen consist of? 1-5 bytes) 
	//(5bytes safer when there is interference but slower data transmission) 5addr-32data-5addr-32data ....	val[0]=0x03;
	WriteToNrf(W, SETUP_AW, val, 1); //0b0000 00011 motsvarar 5byte RF_Adress
 1ac:	81 e0       	ldi	r24, 0x01	; 1
 1ae:	63 e0       	ldi	r22, 0x03	; 3
 1b0:	a7 01       	movw	r20, r14
 1b2:	21 e0       	ldi	r18, 0x01	; 1
 1b4:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
 
	//RF channel setup - select the frequency from 2.400 to 2.527 GHz 1MHz/steg
	val[0]=0x01;
 1b8:	19 83       	std	Y+1, r17	; 0x01
	WriteToNrf(W, RF_CH, val, 1); //RF channel registry 0b0000 0001 = 2.401 GHz (same on the TX RX)
 1ba:	81 e0       	ldi	r24, 0x01	; 1
 1bc:	65 e0       	ldi	r22, 0x05	; 5
 1be:	a7 01       	movw	r20, r14
 1c0:	21 e0       	ldi	r18, 0x01	; 1
 1c2:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
 
	//RF setup - select power and transmission
	val[0]=0x07;
 1c6:	87 e0       	ldi	r24, 0x07	; 7
 1c8:	89 83       	std	Y+1, r24	; 0x01
	//00000111 bit 3 = "0" produces lower transmission rate 1Mbps = Longer range, bit 2-1 gives power 
	//high (-0dB) ("11" = (-18dB) gives lower power = more power-efficient, but lower range
	WriteToNrf(W, RF_SETUP, val, 1);  
 1ca:	81 e0       	ldi	r24, 0x01	; 1
 1cc:	66 e0       	ldi	r22, 0x06	; 6
 1ce:	a7 01       	movw	r20, r14
 1d0:	21 e0       	ldi	r18, 0x01	; 1
 1d2:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
	//RX RF_Adress setup 5 bytes - choose RF_Adressen on The receiver
	// (Must be given the same RF_Adress if the transmitter has EN_AA turned on!)
	int i;
	for(i=0; i<5; i++)	
	{
		val[i]=0x12;//RF channel registry 0b10101011 x 5 
 1d6:	12 e1       	ldi	r17, 0x12	; 18
 1d8:	19 83       	std	Y+1, r17	; 0x01
 1da:	1a 83       	std	Y+2, r17	; 0x02
 1dc:	1b 83       	std	Y+3, r17	; 0x03
 1de:	1c 83       	std	Y+4, r17	; 0x04
 1e0:	1d 83       	std	Y+5, r17	; 0x05
		//- writes the same RF_Adress 5 times to get an easy and safe RF_Adress (same on the transmitter chip!)
	}
	WriteToNrf(W, RX_ADDR_P0, val, 5); // 0b0010 1010 write registry 
 1e2:	81 e0       	ldi	r24, 0x01	; 1
 1e4:	6a e0       	ldi	r22, 0x0A	; 10
 1e6:	a7 01       	movw	r20, r14
 1e8:	25 e0       	ldi	r18, 0x05	; 5
 1ea:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
	
	//TX RF_Adress setup 5 byte -  choose RF_Adressen on transmitter (can be commented out on a "clean" Reciver)
	//int i; //reuse previous i
	for(i=0; i<5; i++)	
	{
		val[i]=0x12;	//RF channel registry 0b10111100 x 5 - writes the same RF_Adress 5 times 
 1ee:	19 83       	std	Y+1, r17	; 0x01
 1f0:	1a 83       	std	Y+2, r17	; 0x02
 1f2:	1b 83       	std	Y+3, r17	; 0x03
 1f4:	1c 83       	std	Y+4, r17	; 0x04
 1f6:	1d 83       	std	Y+5, r17	; 0x05
		//to get an easy and safe RF_Adress 
		//(same on the Receiver chip and the RX-RF_Adressen above if EN_AA enabled!)
	}
	WriteToNrf(W, TX_ADDR, val, 5);
 1f8:	81 e0       	ldi	r24, 0x01	; 1
 1fa:	60 e1       	ldi	r22, 0x10	; 16
 1fc:	a7 01       	movw	r20, r14
 1fe:	25 e0       	ldi	r18, 0x05	; 5
 200:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
 
	//Payload width setup - How many bytes will be sent by air? 1-32byte
	val[0]=dataLen;	//"0b0000 0001" = 1 byte per 5bytes RF_Adress 
 204:	85 e0       	ldi	r24, 0x05	; 5
 206:	89 83       	std	Y+1, r24	; 0x01
	//(can choose up to "0b00100000" = 32byte/5byte RF_Adress) 
	//(defined at the top of the global variable!)
	WriteToNrf(W, RX_PW_P0, val, 1);
 208:	81 e0       	ldi	r24, 0x01	; 1
 20a:	61 e1       	ldi	r22, 0x11	; 17
 20c:	a7 01       	movw	r20, r14
 20e:	21 e0       	ldi	r18, 0x01	; 1
 210:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
	
	//CONFIG reg setup - Now everything is set up, boot up nrf'en and make it either Transmitter lr Reciver
	val[0]=0x1E;  //0b0000 1110 config registry bit "1": 1 = power up, bit "0": 0 = Transmitter 
 214:	8e e1       	ldi	r24, 0x1E	; 30
 216:	89 83       	std	Y+1, r24	; 0x01
	//(bit "0": 1 = Reciver) (bit "4": 1 => mask_Max_RT, ie IRQ vector will not respond if the transmission failed.
	WriteToNrf(W, CONFIG, val, 1);
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	60 e0       	ldi	r22, 0x00	; 0
 21c:	a7 01       	movw	r20, r14
 21e:	21 e0       	ldi	r18, 0x01	; 1
 220:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
 224:	88 ee       	ldi	r24, 0xE8	; 232
 226:	93 e0       	ldi	r25, 0x03	; 3
 228:	20 e9       	ldi	r18, 0x90	; 144
 22a:	31 e0       	ldi	r19, 0x01	; 1
 22c:	f9 01       	movw	r30, r18
 22e:	31 97       	sbiw	r30, 0x01	; 1
 230:	f1 f7       	brne	.-4      	; 0x22e <nrf24L01_init+0xde>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 232:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 234:	d9 f7       	brne	.-10     	; 0x22c <nrf24L01_init+0xdc>
 
//device need 1.5ms to reach standby mode
	_delay_ms(100);	
 
	//sei();	
}
 236:	0f 90       	pop	r0
 238:	0f 90       	pop	r0
 23a:	0f 90       	pop	r0
 23c:	0f 90       	pop	r0
 23e:	0f 90       	pop	r0
 240:	cf 91       	pop	r28
 242:	df 91       	pop	r29
 244:	1f 91       	pop	r17
 246:	ff 90       	pop	r15
 248:	ef 90       	pop	r14
 24a:	08 95       	ret

0000024c <receive_payload>:

/**************************************************************************************************************/
//receive data
void receive_payload(void)
{
	sei();		//Enable global interrupt
 24c:	78 94       	sei
	
	PORTB |= (1 << 1);	//CE goes high, "listening"
 24e:	29 9a       	sbi	0x05, 1	; 5
 250:	80 e1       	ldi	r24, 0x10	; 16
 252:	97 e2       	ldi	r25, 0x27	; 39
 254:	20 e9       	ldi	r18, 0x90	; 144
 256:	31 e0       	ldi	r19, 0x01	; 1
 258:	f9 01       	movw	r30, r18
 25a:	31 97       	sbiw	r30, 0x01	; 1
 25c:	f1 f7       	brne	.-4      	; 0x25a <receive_payload+0xe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 25e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 260:	d9 f7       	brne	.-10     	; 0x258 <receive_payload+0xc>
	_delay_ms(1000);	//Listen for 1 second, interrupt int0 executes
	PORTB &= ~(1 << 1); //CE goes low, "stop listening"
 262:	29 98       	cbi	0x05, 1	; 5
	
	cli();	//Disable global interrupt
 264:	f8 94       	cli
}
 266:	08 95       	ret

00000268 <transmit_payload>:
 
//Send data
void transmit_payload(uint8_t * W_buff)
{
 268:	0f 93       	push	r16
 26a:	1f 93       	push	r17
 26c:	8c 01       	movw	r16, r24
//send 0xE1 which flushes the registry of old data which should not be waiting to be sent when you want to send
// the new data! R stands for W_REGISTER not be added. sends no command efterråt because it is 
//not needed! W_buff [] is just there because an array has to be there ..
	WriteToNrf(R, FLUSH_TX, W_buff, 0);
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	61 ee       	ldi	r22, 0xE1	; 225
 272:	a8 01       	movw	r20, r16
 274:	20 e0       	ldi	r18, 0x00	; 0
 276:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
	WriteToNrf(R, W_TX_PAYLOAD, W_buff, dataLen);//send data in W_buff to nrf-one(cannot read w_tx_payload registry!)
 27a:	80 e0       	ldi	r24, 0x00	; 0
 27c:	60 ea       	ldi	r22, 0xA0	; 160
 27e:	a8 01       	movw	r20, r16
 280:	25 e0       	ldi	r18, 0x05	; 5
 282:	0e 94 69 00 	call	0xd2	; 0xd2 <WriteToNrf>
	
	sei();	//enable global interrupts
 286:	78 94       	sei
 288:	80 e4       	ldi	r24, 0x40	; 64
 28a:	9c e9       	ldi	r25, 0x9C	; 156
 28c:	fc 01       	movw	r30, r24
 28e:	31 97       	sbiw	r30, 0x01	; 1
 290:	f1 f7       	brne	.-4      	; 0x28e <transmit_payload+0x26>
	//USART_Transmit(GetReg(STATUS));
 
	_delay_ms(10);		//necessary delay
	PORTB |= (1 << 1);	//CE high, send data, int0 interrupt
 292:	29 9a       	sbi	0x05, 1	; 5
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 294:	2a e6       	ldi	r18, 0x6A	; 106
 296:	2a 95       	dec	r18
 298:	f1 f7       	brne	.-4      	; 0x296 <transmit_payload+0x2e>
	_delay_us(20);		//at least 10us needed
	PORTB &= ~(1 << 1);	//CE low
 29a:	29 98       	cbi	0x05, 1	; 5
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 29c:	01 97       	sbiw	r24, 0x01	; 1
 29e:	f1 f7       	brne	.-4      	; 0x29c <transmit_payload+0x34>
	_delay_ms(10);		//necessary delay
 
	//cli();	//Disable global interrupt.. 
}
 2a0:	1f 91       	pop	r17
 2a2:	0f 91       	pop	r16
 2a4:	08 95       	ret

000002a6 <main>:
//void WriteToNrf(uint8_t reg, uint8_t Package);
//void initTimer0(void);
//======================

int main (void)
{
 2a6:	ef 92       	push	r14
 2a8:	ff 92       	push	r15
 2aa:	0f 93       	push	r16
 2ac:	1f 93       	push	r17
 2ae:	df 93       	push	r29
 2b0:	cf 93       	push	r28
 2b2:	00 d0       	rcall	.+0      	; 0x2b4 <main+0xe>
 2b4:	00 d0       	rcall	.+0      	; 0x2b6 <main+0x10>
 2b6:	0f 92       	push	r0
 2b8:	cd b7       	in	r28, 0x3d	; 61
 2ba:	de b7       	in	r29, 0x3e	; 62
	DDRC |= (1 << 5); //port c bit 5 set as output so we can use the LED as an indicator
 2bc:	3d 9a       	sbi	0x07, 5	; 7
	SPI_MasterInit(); //initialize SPI 
 2be:	0e 94 48 00 	call	0x90	; 0x90 <SPI_MasterInit>
	INT0_interrupt_init();//INT0 interrupt is triggered when CE pin switches, signals data transfer to nRF
 2c2:	0e 94 5e 00 	call	0xbc	; 0xbc <INT0_interrupt_init>
	nrf24L01_init();//initalizes the nrF module to our desired specifications(channel,power,data width,TX/RX)
 2c6:	0e 94 a8 00 	call	0x150	; 0x150 <nrf24L01_init>
	
	PORTC |= (1 << 5);//turn LED on
 2ca:	45 9a       	sbi	0x08, 5	; 8
 2cc:	88 e8       	ldi	r24, 0x88	; 136
 2ce:	93 e1       	ldi	r25, 0x13	; 19
 2d0:	20 e9       	ldi	r18, 0x90	; 144
 2d2:	31 e0       	ldi	r19, 0x01	; 1
 2d4:	f9 01       	movw	r30, r18
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	f1 f7       	brne	.-4      	; 0x2d6 <main+0x30>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 2da:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 2dc:	d9 f7       	brne	.-10     	; 0x2d4 <main+0x2e>
	_delay_ms(500);//this is to test LED operation
	PORTC &= ~(1 << 5);//turn LED back off
 2de:	45 98       	cbi	0x08, 5	; 8
	uint8_t W_Buffer[5];
	int i;
	
	for(i = 0; i < 5; i++)
		{
			W_Buffer[i] = 0x0F;
 2e0:	8f e0       	ldi	r24, 0x0F	; 15
 2e2:	89 83       	std	Y+1, r24	; 0x01
 2e4:	8a 83       	std	Y+2, r24	; 0x02
 2e6:	8b 83       	std	Y+3, r24	; 0x03
 2e8:	8c 83       	std	Y+4, r24	; 0x04
 2ea:	8d 83       	std	Y+5, r24	; 0x05
		}
	
	while(1)
	{
		transmit_payload(W_Buffer);//repeatedly send data to test if module works
 2ec:	7e 01       	movw	r14, r28
 2ee:	08 94       	sec
 2f0:	e1 1c       	adc	r14, r1
 2f2:	f1 1c       	adc	r15, r1
 2f4:	00 e9       	ldi	r16, 0x90	; 144
 2f6:	11 e0       	ldi	r17, 0x01	; 1
 2f8:	c7 01       	movw	r24, r14
 2fa:	0e 94 34 01 	call	0x268	; 0x268 <transmit_payload>
 2fe:	80 e2       	ldi	r24, 0x20	; 32
 300:	9e e4       	ldi	r25, 0x4E	; 78
 302:	f8 01       	movw	r30, r16
 304:	31 97       	sbiw	r30, 0x01	; 1
 306:	f1 f7       	brne	.-4      	; 0x304 <main+0x5e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 308:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 30a:	d9 f7       	brne	.-10     	; 0x302 <main+0x5c>
 30c:	f5 cf       	rjmp	.-22     	; 0x2f8 <main+0x52>

0000030e <reset>:
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 30e:	85 e3       	ldi	r24, 0x35	; 53
 310:	98 2f       	mov	r25, r24
 312:	9a 95       	dec	r25
 314:	f1 f7       	brne	.-4      	; 0x312 <reset+0x4>
/**************************************************************************************************************/

void reset(void)//called after a successful data transmission
{
	_delay_us(10);
	PORTB &= ~(1 << 2);//CSN low
 316:	2a 98       	cbi	0x05, 2	; 5
 318:	8a 95       	dec	r24
 31a:	f1 f7       	brne	.-4      	; 0x318 <reset+0xa>

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
 31c:	87 e2       	ldi	r24, 0x27	; 39
 31e:	8e bd       	out	0x2e, r24	; 46
	/*Wait for transmission*/
	while(!(SPSR & (1 << SPIF)))
 320:	0d b4       	in	r0, 0x2d	; 45
 322:	07 fe       	sbrs	r0, 7
 324:	fd cf       	rjmp	.-6      	; 0x320 <reset+0x12>
		;
	return SPDR;//return what's recieved to the nRF
 326:	8e b5       	in	r24, 0x2e	; 46
 328:	85 e3       	ldi	r24, 0x35	; 53
 32a:	8a 95       	dec	r24
 32c:	f1 f7       	brne	.-4      	; 0x32a <reset+0x1c>

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
 32e:	80 e7       	ldi	r24, 0x70	; 112
 330:	8e bd       	out	0x2e, r24	; 46
	/*Wait for transmission*/
	while(!(SPSR & (1 << SPIF)))
 332:	0d b4       	in	r0, 0x2d	; 45
 334:	07 fe       	sbrs	r0, 7
 336:	fd cf       	rjmp	.-6      	; 0x332 <reset+0x24>
		;
	return SPDR;//return what's recieved to the nRF
 338:	8e b5       	in	r24, 0x2e	; 46
 33a:	85 e3       	ldi	r24, 0x35	; 53
 33c:	8a 95       	dec	r24
 33e:	f1 f7       	brne	.-4      	; 0x33c <reset+0x2e>
	_delay_us(10);
	WriteByteSPI(W_REGISTER + STATUS);	//
	_delay_us(10);
	WriteByteSPI(0b01110000);	//radedrar alla irq i statusregistret (för att kunna lyssna igen)
	_delay_us(10);
	PORTB |= (1 << 2);	//CSN back to high, nRF doing nothing
 340:	2a 9a       	sbi	0x05, 2	; 5
}
 342:	08 95       	ret

00000344 <__vector_1>:

//vector that is triggered when transmit_payload managed to send or when 
//receive_payload received data NOTE: when Mask_Max_rt is set in the config register 
//so it will not go off when MAX_RT is was reached on the mailing lodge nmisslyckats!
ISR(INT0_vect)
{
 344:	1f 92       	push	r1
 346:	0f 92       	push	r0
 348:	0f b6       	in	r0, 0x3f	; 63
 34a:	0f 92       	push	r0
 34c:	11 24       	eor	r1, r1
 34e:	2f 93       	push	r18
 350:	3f 93       	push	r19
 352:	8f 93       	push	r24
 354:	9f 93       	push	r25
 356:	ef 93       	push	r30
 358:	ff 93       	push	r31
	cli();	//Disable global interrupt
 35a:	f8 94       	cli
	PORTB &= ~(1 << 1);//CE back to low-"stop listening/transmitting"
 35c:	29 98       	cbi	0x05, 1	; 5
	
	PORTC |= (1 << 5);//turn LED on if status is read //led on
 35e:	45 9a       	sbi	0x08, 5	; 8
 360:	88 e8       	ldi	r24, 0x88	; 136
 362:	93 e1       	ldi	r25, 0x13	; 19
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 364:	20 e9       	ldi	r18, 0x90	; 144
 366:	31 e0       	ldi	r19, 0x01	; 1
 368:	f9 01       	movw	r30, r18
 36a:	31 97       	sbiw	r30, 0x01	; 1
 36c:	f1 f7       	brne	.-4      	; 0x36a <__vector_1+0x26>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 36e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 370:	d9 f7       	brne	.-10     	; 0x368 <__vector_1+0x24>
	_delay_ms(500);
	PORTC &= ~(1 << 5); //led off
 372:	45 98       	cbi	0x08, 5	; 8
	//for (int i=0;i<dataLen;i++)
	//{
		//USART_Transmit(data[i]);
	//}
	//
	sei();
 374:	78 94       	sei
}
 376:	ff 91       	pop	r31
 378:	ef 91       	pop	r30
 37a:	9f 91       	pop	r25
 37c:	8f 91       	pop	r24
 37e:	3f 91       	pop	r19
 380:	2f 91       	pop	r18
 382:	0f 90       	pop	r0
 384:	0f be       	out	0x3f, r0	; 63
 386:	0f 90       	pop	r0
 388:	1f 90       	pop	r1
 38a:	18 95       	reti

0000038c <GetReg>:
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 38c:	95 e3       	ldi	r25, 0x35	; 53
 38e:	29 2f       	mov	r18, r25
 390:	2a 95       	dec	r18
 392:	f1 f7       	brne	.-4      	; 0x390 <GetReg+0x4>
//Read a register on the nRF
uint8_t GetReg(uint8_t reg)
{	
	//begin with a delay for timing purposes
	_delay_us(10);	
	PORTB &= ~(1 << 2);//CSN low
 394:	2a 98       	cbi	0x05, 2	; 5
 396:	9a 95       	dec	r25
 398:	f1 f7       	brne	.-4      	; 0x396 <GetReg+0xa>

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
 39a:	8e bd       	out	0x2e, r24	; 46
	/*Wait for transmission*/
	while(!(SPSR & (1 << SPIF)))
 39c:	0d b4       	in	r0, 0x2d	; 45
 39e:	07 fe       	sbrs	r0, 7
 3a0:	fd cf       	rjmp	.-6      	; 0x39c <GetReg+0x10>
		;
	return SPDR;//return what's recieved to the nRF
 3a2:	8e b5       	in	r24, 0x2e	; 46
 3a4:	85 e3       	ldi	r24, 0x35	; 53
 3a6:	8a 95       	dec	r24
 3a8:	f1 f7       	brne	.-4      	; 0x3a6 <GetReg+0x1a>

//send or recieve a byte from the nRF
char WriteByteSPI(unsigned char cData)
{
	/*Start Transmission*/
	SPDR = cData;
 3aa:	8f ef       	ldi	r24, 0xFF	; 255
 3ac:	8e bd       	out	0x2e, r24	; 46
	/*Wait for transmission*/
	while(!(SPSR & (1 << SPIF)))
 3ae:	0d b4       	in	r0, 0x2d	; 45
 3b0:	07 fe       	sbrs	r0, 7
 3b2:	fd cf       	rjmp	.-6      	; 0x3ae <GetReg+0x22>
		;
	return SPDR;//return what's recieved to the nRF
 3b4:	8e b5       	in	r24, 0x2e	; 46
 3b6:	95 e3       	ldi	r25, 0x35	; 53
 3b8:	9a 95       	dec	r25
 3ba:	f1 f7       	brne	.-4      	; 0x3b8 <GetReg+0x2c>
	_delay_us(10);
	WriteByteSPI(R_REGISTER + reg);	//R_Register = set nRF to reading mode, "reg" will be read back
	_delay_us(10);
	reg = WriteByteSPI(NOP);//Send dummy byte to recieve back first byte in reg register
	_delay_us(10);
	PORTB |= (1 << 2);	//CSN back to high, nRF doing nothing
 3bc:	2a 9a       	sbi	0x05, 2	; 5
	return reg;	// Return the read registry
}
 3be:	08 95       	ret

000003c0 <_exit>:
 3c0:	f8 94       	cli

000003c2 <__stop_program>:
 3c2:	ff cf       	rjmp	.-2      	; 0x3c2 <__stop_program>
